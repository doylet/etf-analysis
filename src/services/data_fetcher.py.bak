"""
Data fetching and persistence utilities
"""

import yfinance as yf
import pandas as pd
from datetime import datetime, timedelta, timedelta
from sqlalchemy import and_, func
from src.models.database import DatabaseManager, Instrument, PriceData, Order


class DataFetcher:
    """Fetch and store financial data"""
    
    def __init__(self, db_manager: DatabaseManager):
        self.db = db_manager
    
    def add_instrument(self, symbol: str, name: str = None, instrument_type: str = 'stock', 
                       sector: str = None, notes: str = None):
        """Add a new instrument to track"""
        session = self.db.get_session()
        try:
            # Check if already exists
            existing = session.query(Instrument).filter_by(symbol=symbol.upper()).first()
            if existing:
                if existing.is_active:
                    return {'success': False, 'message': f'{symbol} already exists'}
                else:
                    # Reactivate previously removed instrument
                    existing.is_active = True
                    if name:
                        existing.name = name
                    existing.instrument_type = instrument_type
                    if sector:
                        existing.sector = sector
                    if notes:
                        existing.notes = notes
                    existing.last_updated = datetime.utcnow()
                    session.commit()
                    return {'success': True, 'message': f'Reactivated {symbol}', 'instrument': existing}
            
            # Fetch basic info from yfinance if name not provided
            if not name:
                ticker = yf.Ticker(symbol)
                try:
                    info = ticker.info
                    name = info.get('longName', info.get('shortName', symbol))
                    if sector is None:
                        sector = info.get('sector', 'Unknown')
                except:
                    name = symbol
                    sector = sector or 'Unknown'
            
            # Create new instrument
            instrument = Instrument(
                symbol=symbol.upper(),
                name=name,
                instrument_type=instrument_type,
                sector=sector,
                notes=notes,
                is_active=True
            )
            session.add(instrument)
            session.commit()
            
            return {'success': True, 'message': f'Added {symbol}', 'instrument': instrument}
        except Exception as e:
            session.rollback()
            return {'success': False, 'message': str(e)}
        finally:
            session.close()
    
    def remove_instrument(self, symbol: str):
        """Deactivate an instrument (soft delete)"""
        session = self.db.get_session()
        try:
            instrument = session.query(Instrument).filter_by(symbol=symbol.upper()).first()
            if not instrument:
                return {'success': False, 'message': f'{symbol} not found'}
            
            instrument.is_active = False
            session.commit()
            return {'success': True, 'message': f'Removed {symbol}'}
        except Exception as e:
            session.rollback()
            return {'success': False, 'message': str(e)}
        finally:
            session.close()
    
    def create_order(self, symbol: str, order_type: str, volume: float, 
                     order_date: datetime = None, notes: str = None):
        """Create a buy/sell order"""
        session = self.db.get_session()
        try:
            instrument = session.query(Instrument).filter_by(symbol=symbol.upper()).first()
            if not instrument:
                return {'success': False, 'message': f'{symbol} not found'}
            
            if order_type not in ['Buy', 'Sell']:
                return {'success': False, 'message': 'Order type must be Buy or Sell'}
            
            if volume <= 0:
                return {'success': False, 'message': 'Volume must be positive'}
            
            order = Order(
                instrument_id=instrument.id,
                symbol=symbol.upper(),
                order_type=order_type,
                volume=volume,
                order_date=order_date or datetime.utcnow(),
                notes=notes
            )
            session.add(order)
            session.commit()
            return {'success': True, 'message': f'Created {order_type} order for {volume} units of {symbol}'}
        except Exception as e:
            session.rollback()
            return {'success': False, 'message': str(e)}
        finally:
            session.close()
    
    def get_net_quantity(self, symbol: str):
        """Calculate net quantity from all orders (Buys - Sells)"""
        session = self.db.get_session()
        try:
            # Sum all Buy orders
            buys = session.query(func.sum(Order.volume)).filter(
                and_(Order.symbol == symbol.upper(), Order.order_type == 'Buy', Order.is_active == 1)
            ).scalar() or 0.0
            
            # Sum all Sell orders
            sells = session.query(func.sum(Order.volume)).filter(
                and_(Order.symbol == symbol.upper(), Order.order_type == 'Sell', Order.is_active == 1)
            ).scalar() or 0.0
            
            return buys - sells
        finally:
            session.close()
    
    def get_orders(self, symbol: str = None, include_deleted: bool = False):
        """Get orders for a symbol or all orders"""
        session = self.db.get_session()
        try:
            query = session.query(Order)
            if not include_deleted:
                query = query.filter_by(is_active=1)
            if symbol:
                query = query.filter_by(symbol=symbol.upper())
            
            orders = query.order_by(Order.order_date.desc()).all()
            return [
                {
                    'id': o.id,
                    'symbol': o.symbol,
                    'order_type': o.order_type,
                    'volume': o.volume,
                    'order_date': o.order_date,
                    'notes': o.notes,
                    'is_active': o.is_active,
                    'created_at': o.created_at
                }
                for o in orders
            ]
        finally:
            session.close()
    
    def delete_order(self, order_id: int):
        """Soft delete an order"""
        session = self.db.get_session()
        try:
            order = session.query(Order).filter_by(id=order_id).first()
            if not order:
                return {'success': False, 'message': 'Order not found'}
            
            order.is_active = 0
            session.commit()
            return {'success': True, 'message': f'Deleted order {order_id}'}
        except Exception as e:
            session.rollback()
            return {'success': False, 'message': str(e)}
        finally:
            session.close()
    
    def create_order(self, symbol: str, order_type: str, volume: float, 
                     order_date: datetime = None, notes: str = None):
        """Create a buy/sell order"""
        session = self.db.get_session()
        try:
            instrument = session.query(Instrument).filter_by(symbol=symbol.upper()).first()
            if not instrument:
                return {'success': False, 'message': f'{symbol} not found'}
            
            if order_type not in ['Buy', 'Sell']:
                return {'success': False, 'message': 'Order type must be Buy or Sell'}
            
            if volume <= 0:
                return {'success': False, 'message': 'Volume must be positive'}
            
            order = Order(
                instrument_id=instrument.id,
                symbol=symbol.upper(),
                order_type=order_type,
                volume=volume,
                order_date=order_date or datetime.utcnow(),
                notes=notes
            )
            session.add(order)
            session.commit()
            return {'success': True, 'message': f'Created {order_type} order for {volume} units of {symbol}'}
        except Exception as e:
            session.rollback()
            return {'success': False, 'message': str(e)}
        finally:
            session.close()
    
    def get_net_quantity(self, symbol: str):
        """Calculate net quantity from all orders (Buys - Sells)"""
        session = self.db.get_session()
        try:
            # Sum all Buy orders
            buys = session.query(func.sum(Order.volume)).filter(
                and_(Order.symbol == symbol.upper(), Order.order_type == 'Buy', Order.is_active == 1)
            ).scalar() or 0.0
            
            # Sum all Sell orders
            sells = session.query(func.sum(Order.volume)).filter(
                and_(Order.symbol == symbol.upper(), Order.order_type == 'Sell', Order.is_active == 1)
            ).scalar() or 0.0
            
            return buys - sells
        finally:
            session.close()
    
    def get_orders(self, symbol: str = None, include_deleted: bool = False):
        """Get orders for a symbol or all orders"""
        session = self.db.get_session()
        try:
            query = session.query(Order)
            
            # Filter by is_active unless include_deleted is True
            if not include_deleted:
                query = query.filter_by(is_active=1)
            
            if symbol:
                query = query.filter_by(symbol=symbol.upper())
            
            orders = query.order_by(Order.order_date.desc()).all()
            return [
                {
                    'id': o.id,
                    'symbol': o.symbol,
                    'order_type': o.order_type,
                    'volume': o.volume,
                    'order_date': o.order_date,
                    'notes': o.notes,
                    'is_active': o.is_active,
                    'created_at': o.created_at
                }
                for o in orders
            ]
        finally:
            session.close()
    
    def get_all_instruments(self, active_only=True):
        """Get all tracked instruments with calculated quantities from orders"""
        session = self.db.get_session()
        try:
            query = session.query(Instrument)
            if active_only:
                query = query.filter_by(is_active=True)
            instruments = query.all()
            
            result = []
            for i in instruments:
                # Calculate net quantity from orders
                quantity = self.get_net_quantity(i.symbol)
                result.append({
                    'symbol': i.symbol,
                    'name': i.name,
                    'type': i.instrument_type,
                    'sector': i.sector,
                    'quantity': quantity,
                    'added_date': i.added_date,
                    'last_updated': i.last_updated,
                    'notes': i.notes
                })
            return result
        finally:
            session.close()
    
    def get_instrument(self, symbol):
        """Get a single instrument by symbol"""
        session = self.db.get_session()
        try:
            instrument = session.query(Instrument).filter_by(symbol=symbol.upper()).first()
            if instrument:
                quantity = self.get_net_quantity(instrument.symbol)
                return {
                    'symbol': instrument.symbol,
                    'name': instrument.name,
                    'type': instrument.instrument_type,
                    'sector': instrument.sector,
                    'quantity': quantity,
                    'added_date': instrument.added_date,
                    'last_updated': instrument.last_updated,
                    'notes': instrument.notes
                }
            return None
        finally:
            session.close()
    
    def search_instruments(self, search_term: str):
        """Search instruments by symbol or name"""
        session = self.db.get_session()
        try:
            search = f"%{search_term.upper()}%"
            instruments = session.query(Instrument).filter(
                and_(
                    Instrument.is_active == True,
                    (Instrument.symbol.like(search) | Instrument.name.like(search))
                )
            ).all()
            return [
                {
                    'symbol': i.symbol,
                    'name': i.name,
                    'type': i.instrument_type,
                    'sector': i.sector
                }
                for i in instruments
            ]
        finally:
            session.close()
    
    def fetch_and_store_prices(self, symbol: str, period: str = '1y', force_refresh: bool = False):
        """Fetch historical prices and store in database"""
        session = self.db.get_session()
        try:
            # Check if instrument exists
            instrument = session.query(Instrument).filter_by(
                symbol=symbol.upper(), is_active=True
            ).first()
            if not instrument:
                return {'success': False, 'message': f'{symbol} not found in tracked instruments'}
            
            # Check if we need to fetch data
            if not force_refresh:
                latest = session.query(PriceData).filter_by(
                    symbol=symbol.upper()
                ).order_by(PriceData.date.desc()).first()
                
                if latest and (datetime.utcnow() - latest.date).days < 1:
                    return {'success': True, 'message': 'Data is up to date', 'cached': True}
            
            # Fetch from yfinance
            ticker = yf.Ticker(symbol)
            df = ticker.history(period=period)
            
            if df.empty:
                return {'success': False, 'message': f'No data available for {symbol}'}
            
            # Store in database
            records_added = 0
            for date, row in df.iterrows():
                # Check if record exists
                existing = session.query(PriceData).filter(
                    and_(
                        PriceData.symbol == symbol.upper(),
                        PriceData.date == date.to_pydatetime()
                    )
                ).first()
                
                if not existing:
                    price_record = PriceData(
                        symbol=symbol.upper(),
                        date=date.to_pydatetime(),
                        open_price=float(row['Open']),
                        high_price=float(row['High']),
                        low_price=float(row['Low']),
                        close_price=float(row['Close']),
                        volume=float(row['Volume'])
                    )
                    session.add(price_record)
                    records_added += 1
            
            # Update instrument last_updated
            instrument.last_updated = datetime.utcnow()
            session.commit()
            
            return {
                'success': True,
                'message': f'Fetched data for {symbol}',
                'records_added': records_added,
                'cached': False
            }
        except Exception as e:
            session.rollback()
            return {'success': False, 'message': str(e)}
        finally:
            session.close()
    
    def get_price_data(self, symbol: str, start_date=None, end_date=None):
        """Retrieve price data from database"""
        session = self.db.get_session()
        try:
            query = session.query(PriceData).filter_by(symbol=symbol.upper())
            
            if start_date:
                query = query.filter(PriceData.date >= start_date)
            if end_date:
                query = query.filter(PriceData.date <= end_date)
            
            query = query.order_by(PriceData.date)
            
            prices = query.all()
            
            if not prices:
                return pd.DataFrame()
            
            df = pd.DataFrame([
                {
                    'date': p.date,
                    'open': p.open_price,
                    'high': p.high_price,
                    'low': p.low_price,
                    'close': p.close_price,
                    'volume': p.volume
                }
                for p in prices
            ])
            df.set_index('date', inplace=True)
            return df
        finally:
            session.close()
    
    def get_latest_prices(self, symbols: list):
        """Get latest close prices for multiple symbols"""
        session = self.db.get_session()
        try:
            results = {}
            for symbol in symbols:
                latest = session.query(PriceData).filter_by(
                    symbol=symbol.upper()
                ).order_by(PriceData.date.desc()).first()
                
                if latest:
                    results[symbol] = {
                        'close': latest.close_price,
                        'date': latest.date
                    }
            return results
        finally:
            session.close()
